spring boot 自动配置的原理
  首先 springboot 启动类 的注解 为 @SpringBootApplication 该注解集成了 三个注解的功能：
  @SpringBootCnfiguration、@ComponentScan、@EnableAutoConfiguration(这个注解就是自动配置的注解)
  @EnableConfiguration注解中 使用@Import导入了 EnableAutoConfigurationImportSelector这个类
  在这个类里 有一个selectImport 方法 调用本类的其他方法来导入位于 META-INF/spring.factories的所有默认配置


String类为什么是final的？
  主要是为了线程安全和效率的缘故
  final修饰的String 不可继承 不可更改 只有这样才可以实现字符串池，String
  是需要大量重用的所以设置为final要安全许多 性能也高许多，


Java中有哪些队列，有哪些区别，
  Queue：基本上， 一个队列就是一个先入先出（FIFO）的数据结构
  Queue接口与List，Set同一级别，都继承了Collection接口。 LinkedList实现了
  Deque接口

  Queue的实现
    一. 没有实现阻塞接口 
      实现java.util.Queue的LinkList
      实现java.util.AbstractQueue内置的不阻塞队列：PriorityQueue和ConcurrentLinkedQueue
    二. 实现阻塞接口的 
      java.util.concurrent 中加入了 BlockingQueue 接口和五个阻塞队列类。
      它实质上就是一种带有一点扭曲的 FIFO 数据结构。不是立即从队列中添加
      或者删除元素，线程执行操作阻塞，直到有空间或者元素可用。

      * ArrayBlockingQueue ：一个由数组支持的有界队列。
　　  * LinkedBlockingQueue ：一个由链接节点支持的可选有界队列。
　　  * PriorityBlockingQueue ：一个由优先级堆支持的无界优先级队列。
　　  * DelayQueue ：一个由优先级堆支持的、基于时间的调度队列。
　　  * SynchronousQueue ：一个利用 BlockingQueue 接口的简单聚集（rendezvous）机制。


详谈一下Java的内存模型以及GC算法
  JVM内存模型 JVM运行时 数据区域被分为以下五个区域
    由所有线程共享的数据区： 方法区、堆
    线程隔离的数据区： 虚拟机栈 本地方法栈 程序计数器
    堆：
      对于大多数应用来说，Java Heap是Java虚拟机管理的内存的最大一块，这块区域
      随着虚拟机的启动而创建。在实际的运用中，我们创建的对象和数组就是存放在堆
      里面。如果你听说线程安全的问题，就会很明确的知道Java Heap是一块共享的
      区域，操作共享区域的成员就有了锁和同步。
      与Java Heap相关的还有Java的垃圾回收机制（GC）,Java Heap是垃圾回收器
      管理的主要区域。程序猿所熟悉的新生代、老生代、永久代的概念就是在堆里
      面，现在大多数的GC基本都采用了分代收集算法。如果再细致一点，Java Heap
      还有Eden空间，From Survivor空间,ToSurvivor空间等。Java Heap可以处于物理
      上不连续的内存空间中，只要逻辑上是连续的即可。
    栈（Java虚拟机栈）：
      相对于Java Heap来讲，Java Stack是线程私有的，她的生命周期与线程相同。
      Java Stack描述的是Java方法执行时的内存模型，每个方法执行时都会创建一个
      栈帧（Stack Frame）用语存储局部变量表、操作数栈、动态链接、方法出口等
      信息。从下图从可以看到，每个线程在执行一个方法时，都意味着有一个栈帧在
      当前线程对应的栈帧中入栈和出栈。
      图中可以看到每一个栈帧中都有局部变量表。局部变量表存放了编译期间的各种
      基本数据类型，对象引用等信息。
    本地方法栈：
      本地方法栈（Native Stack）与Java虚拟机栈（JavaStack）所发挥的作用非常
      相似，他们之间的区别在于虚拟机栈为虚拟机栈执行java方法（也就是字节码）
      服务，而本地方法栈则为使用到Native方法服务。
    方法区：
      方法区（Method Area）与堆（JavaHeap）一样，是各个线程共享的内存区域，
      它用于存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等
      数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是她却有一个
      别名叫做非堆（Non-Heap）。分析下Java虚拟机规范，之所以把方法区描述为堆
      的一个逻辑部分，应该觉得她们都是存储数据的角度出发的。一个存储对象数据
      （堆），一个存储静态信息(方法区)。
    程序计数器:
      程序计数器是众多编程语言都共有的一部分，作用是标示下一条需要执行的指令的
      位置，分支、循环、跳转、异常处理、线程恢复等基础功能都是依赖程序计数器
      完成的。
      对于Java的多线程程序而言，不同的线程都是通过轮流获得cpu的时间片运行的，
      这符合计算机组成原理的基本概念，因此不同的线程之间需要不停的获得运行，
      挂起等待运行，所以各线程之间的计数器互不影响，独立存储。这些数据区属于
      线程私有的内存。

  GC算法 
    标记清除算法：
      1、标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象
      2、在标记完成后统一回收所有被标记的对象
      缺点：一个是效率问题，标记和清除两个过程的效率都不高；
        另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中
        需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
    复制算法：
      1、将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。
      2、当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
      优点：这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等
        复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为
        了原来的一半，未免太高了一点。
      缺点：复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低
    标记整理算法：
      1、标记
      2、让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存
    分代收集：
      1、根据对象存活周期的不同将内存划分为几块。
      2、一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。
      3、在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出
        少量存活对象的复制成本就可以完成收集。
      4、老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。


SpringMVC运行原理 
    1. 客户端请求提交到DispatcherServlet 
    2. 由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller 
    3. DispatcherServlet将请求提交到Controller 
    4. Controller调用业务逻辑处理后，返回ModelAndView 
    5. DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图 
    6. 视图负责将结果显示到客户端 DispatcherServlet是整个Spring MVC的核心。它负责接收HTTP请求组织协调Spring MVC的各个组成部分。      


Java中引用类型都有哪些？
    Java中对象的引用分为四种级别，这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。
      强引用（StrongReference）
        这个就不多说， 我们写代码天天在用的就是强引用。 如果一个对象被人拥有强引用，那么垃圾
        回收绝不会回收它。当内存空间不足， 虚拟机宁愿抛出OutOfMemoryError错误，使程序终止，
        也不会回收具有强引用的对象来解决内存不足问题。
      软引用（SoftReference）
        一个对象只有软引用的话，如果内存空间足够，垃圾回收器就不会回收它，如果内存
        空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以
        被程序使用，软引用可用来实现内存敏感对的高速缓存
      弱引用（WeakReference）
        如果一个对象只具有弱引用，那该类就是可有可无的对象，因为只要该对象被gc扫描到了
        随时都会把它干掉。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命
        周期在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，
        不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低
        的线程， 因此不一定会很快发现那些只具有弱引用的对象
      虚引用（PhantomReference）
        形同虚设，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能
        被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。

      
spring的事务隔离级别和基本原理
  事务的定义：
    事务是指多个操作单元组成的合集，多个单元操作是整体不可分割的，要么都操作不成功，要么
    都成功。其必须遵循四个原则（ACID）。
      1. 原子性（Atomicity）：即事务是不可分割的最小工作单元，事务内的操作要么全做，要么
        全不做
      2. 一致性（Consistency）：在事务执行前数据库的数据处于正确的状态，而事务执行完成后
        数据库的数据还是应该处于正确的状态，即数据完整性约束没有被破坏；
      3. 隔离性（Isolation）：并发事务执行之间互不影响，在一个事务内部的操作对其他事务是
        不产生影响，这需要事务隔离级别来指定隔离性
      4.持久性（Durability）：事务一旦执行成功，它对数据库的数据的改变必须是永久的，不会
        因比如系统故障或断电造成数据不一致或丢失
    隔离级别	    隔离级别的值	导致的问题
      Read-Uncommitted    0	          导致脏读
      Read-Committed	  1	          避免脏读，允许不可重复读和幻读
      Repeatable-Read	  2	          避免脏读，不可重复读，允许幻读（可重复读）
      Serializable	  3	          串行化读，事务只能一个一个执行，避免了脏读、不可重复读、幻读。执行效率慢，使用时慎重
    
    脏读：一事务对数据进行了增删改，但未提交，另一事务可以读取到未提交的数据。如果第一个事务这时候
      回滚了，那么第二个事务就读到了脏数据。
    不可重复读：一个事务中发生了两次读操作，第一次读操作和第二次操作之间，另外一个事务对数据进行了
      修改，这时候两次读取的数据是不一致的。
    幻读：第一个事务对一定范围的数据进行批量修改，第二个事务在这个范围增加一条数据，这时候第一个事
    务就会丢失对新增数据的修改。
    总结：
    隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。
    大多数的数据库默认隔离级别为 Read Commited，比如 SqlServer、Oracle
    少数数据库默认隔离级别为：Repeatable Read 比如： MySQL InnoDB


spring 框架IOC和AOP的实现原理
  是指容器控制程序对象之间的关系，而不是传统实现中，由程序代码直接操控。控制权由应用代码中转到了外部
  容器，控制权的转移是所谓反转。 对于Spring而言，就是由Spring来控制对象的生命周期和对象之间的关系；
  IoC还有另外一个名字——“依赖注入（Dependency Injection）”。从名字上理解，所谓依赖注入，即组件之间的依
  赖关系由容器在运行期决定，即由容器动态地将某种依赖关系注入到组件之中。 

Synchronized与ReentrantLock区别总结
  相似点：
    这两种同步方式有很多相似之处，它们都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程
    获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤
    醒的代价是比较高的（操作系统需要在用户态与内核态之间来回切换，代价很高，不过可以通过对锁优化进行
    改善）。

  功能区别：
    这两种方式最大区别就是对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm
    实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合
    try/finally语句块来完成
    便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而
    ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中
    声明释放锁。
    锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized

  性能的区别：
    在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了
    偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用
    synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就
    把加锁问题解决，避免进入内核态的线程阻塞。


Redis 的数据类型 
Redis 有五种数据类型: string(字符串), hash(哈希), list(列表), set(集合),及 zset(sorted set:有序集合).






























